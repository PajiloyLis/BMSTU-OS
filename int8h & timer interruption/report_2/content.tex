\chapter{Функции обработчика прерывания от системного таймера}

\section{UNIX/Linux}

\textbf{По тику:}
\begin{itemize}
    \item инкремент системных таймеров (например, переменной lbolt, хранящей количество тиков, осчитанных с момента загрузки системы);
    \item декрмент счетчиков времени до отправления на выполнение отложенного вызова (флаг для обработчика отложенных вызовов выставляется,  если счетчик достиг нуля);
    \item декремент кванта текущего потока.
\end{itemize}

\textbf{По главному тику:}
\begin{itemize}
    \item инициализация (установка флага обработчика отложенных вызовов, при наличии ожидающих вызовов) отложенных вызовов функций, связанных с работой планировщика, например, пересчет приоритетов;
    \item регистрация отложенного вызова процедуры wakeup для системных процессов, например swapper и kswapd;
    \item декремент счетчика времени до посылки одного из сигналов:
    \begin{itemize}
    \item SIGALARM --- посылается процессу по истечении времени, заданного предварительно функцией alarm;
    \item SIGPROF --- посылается процессу по истечении времени, заданного в таймере профилирования (общее время выполнения процесса);
    \item SIGVTALRM --- посылается процессу по истичении времени, заданного в <<виртуальном>> таймере (время выполнения процесса в режиме задачи).
    \end{itemize}
\end{itemize}

\textbf{По кванту:}
\begin{itemize}
    \item отправка сигнала SIGXCPU процессу по истечении выделенного ему кванта (при получении данного сигнала процесс прерывает свое выполнение, либо диспетчер выделяет ему еще один квант).
\end{itemize}

\section{Windows}

\textbf{По тику:}
\begin{itemize}
    \item инкремент счетчика системного времени;
    \item декремент счетчиков времени отложенных задач;
    \item декремент кванта текущего потока.
\end{itemize}

\textbf{По главному тику:}
\begin{itemize}
    \item раз в секунду инициализация диспетчера настройки баланса, путем сброса объекта <<событие>>, на котором он ожидает.
\end{itemize}

\textbf{По кванту:}
\begin{itemize}
    \item инициализация диспетчеризации потоков --- постановка соответствующего объекта в очередь DPC.
\end{itemize}

\chapter{Пересчет динамических приоритетов}

В ОС семейства UNIX и в ОС семейства Windows пересчитываться могут только приоритеты пользовательских процессов.

\section{UNIX/Linux}

В традиционном UNIX ядро является строго не вытесняющим --- процесс в режие ядра не может быть вытеснен другим более приоритетным процессом. В современных система UNIX ядро является вытесняющим, т.~е. процесс в режиме ядра может быть вытеснен более приоритетным процессом. Вытесняющее ядро позволяет системе обслуживать прцоессы реального времени.

\subsection{Приоритеты процессов}

Очередь готовых к выполнению процессов формируется в соответствии с приоритетами и приниципом вытесняющего циклического планирования: процессы с одинаковыми приоритетами выполняются в течении кванта времени друг за другом циклически. Если в очередь готовых к выполнению процессов поступает более приоритетный, чем выполняющийся сейчас, процесс, планировщик вытесняет текующий процесс и предоставляет квант более приоритетному процессу.

Приоритет в UNIX задается целым числом в диапазоне от 0 до 127. Чем меньше значение, тем выше приоритет процесса. Приоритеты 0~--~49 зарезервированы для процессов ядра, приоритеты 50~--~127 предназначаются прикладным процессам. Т.~к. пересчитываться могут только приоритеты пользовательских процессов, приоритеты процессов ядра являются статическими. Приоритеты прикладных процессов могут изменяться в зависимости от фактора <<любезности>> и степени загруженности процессора в момент последнего обновления.

Фактор <<любезности>> процесса --- целое число в диапазоне от 0 до 39. Чем меньше значение этого фактора, тем выше приоритет процесса. По умолчанию значение фактора <<любезности>>  --- 20. Фактор <<любезности>> процесса может быть изменен суперпользователем системным вызовом \textbf{nice}. Фоновые процессы обладают большими значениями фактора <<любезности>>.

В дескрипторе процесса \textbf{proc} содержатся поля, которые относятся к приоритету процесса:
\begin{itemize}
    \item \textbf{p_pri} --- текущий приоритет планирования;
    \item \textbf{p_usrpri} --- приоритет процесса в режиме задачи;
    \item \textbf{p_cpu} --- результат последнего измереня степени загруженности процессора;
    \item \textbf{p_nice} --- фактор любезности, устанавливаемый пользователем.
\end{itemize}

Для процесса находящегося в режиме задачи, значения \textbf{p_pri} и \textbf{p_usrpri} равны. Значение текущего приоритета \textbf{p_pri} может быть временно повышено планировщиком для выполнения процесса в режиме ядра, при этом \textbf{p_usrpri} будет использован для хранения приоритета процесса при возвращении в режим задачи.

Ядро системы связывает приоритет сна с событием или ожидаемым ресурсом, из-за которого процесс может быть блокирован. Когда процесс просыпается, после блокировки в системном вызове, ядро устанавливает приоритет сна в поле \textbf{p_pri} --- значение от 0 до 49, в зависимости от того, по какому событию или ресурсу произошла блокирвка. Такой процесс будет приоритетнее процессов в режиме задачи. В таблице~\ref{tab:sleep_pri} приведены приоритеты сна для систем 4.3~BSD и SCO UNIX. 
\begin{table}[H]
	\caption{Приоритеты сна в ОС 4.3~BSD и SCO UNIX}
	\centering
	\begin{tabular}{|l|l|l|}
		\hline
		\textbf{Событие} & \textbf{\shortstack[l]{Приоритет\\ 4.3~BSD}} & \textbf{\shortstack[l]{Приоритет\\ SCO UNIX}}\\\hline
            Ожидание загрузки в память сегомента/страницы & 0 & 95\\\hline
            Ожидание индексного дескриптора&10&88\\\hline
Ожидание ввода-вывода&20&81\\\hline
Ожидание буфера&30&80\\\hline
Ожидание терминального ввода&&75\\\hline
Ожидание терминального вывода&&74\\\hline
Ожидание завершения выполнения&&73\\\hline
\shortstack[l]{Ожидание события— низкоприоритетное\\состояние сна}&40&66\\\hline
	\end{tabular}
	\label{tab:sleep_pri}
\end{table}

При создании процесса полю \textbf{p_cpu} присваивается значение 0. На каждом тике обработчик прерывания таймера икрементирует это поле для текузего процесса, до максимального значения, равного 127.

Каждую секунду, обработчик прерывания таймера инициализирует отложенный вызов процедуры \textbf{schedcpy}, которая уменьшает значение \textbf{p_cpu} в соответстви с фактором полураспада. В 4.3~BSD для расчета этого фактора применяется формула:
$$
decay = \frac{2\cdot load_average}{2\cdot load_average + 1}
$$
где \textit{load\_average} --- среднее количество процессов, находящихся в состоянии готовности к выполнению за последнюю секунду.

Приоритеты всех процессов в режиме задачи в процедуре \textbf{schedcpy} пересчитываются по формуле:
$$
p_usrpri = PUSER + \frac{p_cpu}{4}+2\cdotp_nice
$$
где \textit{PUSER} --- базовый приоритет процесса в режиме задачи, равный 50. 

Если процесс в последний раз использовал большое количество процессорного времени,
поле \textbf{p\_cpu} его дексриптора будет увеличено. Это приведёт к росту значения \textbf{p\_usrpri} и понижению приоритета.
Чем дольше процесс находится в очереди на исполнение, тем больше фактор полураспада
уменьшает значение \textbf{p\_cpu}, что приводит к повышению его приоритета. Данная схема предотвращает
бесконечное откладывание низкоприоритетных процессов. Применение такой схемы более
предпочтительно для процессов, которые осуществляют много операций ввода-вывода, и менее предпочтительно для процессов, производящих много вычислений.

\subsection{Потоки в UNIX}
В современном UNIX потоки являются единицей диспетчеризации. Для приоритизации
потоков используется три класса планирования.

\textbf{Классы планирования:}
\begin{itemize}
    \item Deadline: Имеет наивысший приоритет. Используется для задач с жёсткими временными ограничениями;
    \item Real-Time: Второй по приоритету класс, предназначен для задач реального времени;
    \item Fair: Предназначен для прикладных задач.

\end{itemize}

\textbf{Приоритеты:}
\begin{enumerate}
    \item NICE: используется для потоков класса Fair и варьируется от -20 (максимальный приоритет) до +19 (минимальный приоритет). Чем выше значение, тем больше поток делится процессорным временем;
\item Real-Time приоритеты: для потоков класса Real-Time приоритеты варьируются от 1
до 99. NICE здесь не используется;
\item  Priority (sched\_priority): определяет политику и приоритет для потоков класса Real-
Time и Deadline. Для потоков класса Deadline приоритет всегда равен 0.

\end{enumerate}

\textbf{Алгоритмы планирования:}
\begin{itemize}
    \item Completely Fair Scheduler – CFS обеспечивает равномерное распределение
процессорного времени, моделируя "идеальный многозадачный CPU". Процессы
сортируются по виртуальному времени (vruntime) в красно-чёрном дереве. Задача с
минимальным vruntime получает процессорное время.
 \item Earliest Eligible Virtual Deadline First --- EEVDF заменил CFS в 2023 году. Алгоритм
ориентирован на своевременное выполнение задач с дедлайнами. Задачи сортируются
по дедлайнам, а параметр eligibility определяет, имеет ли задача право на выполнение.

\end{itemize}

\section{Windows}

В ОС семейства Windows процессу при создании присваивается базовый приоритет.
Относительно базового приоритета высчитывается относительный приоритет. Планирование
осуществляется на основе приоритетов потоков, готовых к выполнению. Потоки с более низким
приоритетом могут быть вытеснены потоками с более высокими приоритетами, когда те будут
готовы к выполнению. По истечению кванта времени текущего потока, ресурс передается
самому приоритетному потоку в очереди готовых к выполнению.

В ОС семейства Windows существует 32 уровня приоритета:
\begin{itemize}
    \item от 0 до 15 — изменяющиеся уровни (уровень 0 зарезервирован для потока обнуления
страниц);
\item от 16 до 31 — уровни реального времени.
\end{itemize}

Система не повышает приоритет потоков с базовым уровнем приоритета от 16 до 31.
Только потоки с базовым приоритетом от 0 до 15 получают динамический приоритет.

Уровни приоритета потоков назначаются с двух позиций: Windows API и ядра
операционной системы. Windows API сортирует процессы по классам приоритета, которые
были назначены при их создании:
\begin{itemize}
    \item реального времени (real-time, 4);
    \item высокий (high, 3);
    \item выше обычного (above normal, 6);
    \item обычный (normal, 2);
    \item ниже обычного (below normal, 5);
    \item простой (idle, 1).
    
\end{itemize}

Функция \textbf{SetPriorityClass} позволяет изменять класс приоритета процесса до одного из
этих уровней.

Затем назначается относительный приоритет потоков в рамках процессов:
\begin{itemize}
    \item критичный по времени (time critical, 15);
    \item наивысший (highest, 2);
    \item выше обычного (above normal, 1);
    \item обычный (normal, 0);
    \item ниже обычного (below normal, -1);
    \item низший (lowest, -2);
    \item  простой (idle, -15).
\end{itemize}

Исходный базовый приоритет потока наследуется от базового приоритета процесса. Процесс по умолчанию наследует свой базовый приоритет у того процесса, который его создал.

Таким образом, в Windows API каждый поток имеет базовый приоритет, являющийся
функцией класса приоритета процесса и его относительного приоритета процесса. В ядре класс
приоритета процесса преобразуется в базовый приоритет. В таблице~\ref{tab:win_kernel_api} приведено соответствие
между приоритетами Windows API и ядра системы приоритета.


\begin{table}[H]
    \caption{Соответствие между приоритетами Windows API и ядра Windows}
    \centering
    \begin{tabular}{|l|l|l|l|l|l|l|}
    \hline
         &\textbf{real-time}& \textbf{high} &\textbf{above normal}  &\textbf{normal}  & \textbf{below normal} & \textbf{idle}\\\hline
         \textbf{time critical}& 31 & 15 & 15 & 15 & 15 & 15\\\hline
         \textbf{highest}& 26 & 15 & 12 & 10 & 8 & 6\\\hline
         \textbf{above normal}& 25 & 14 & 11 & 9 & 7 & 5\\\hline
         \textbf{normal}& 24 & 13 & 10 & 8 & 6 & 4\\\hline
         \textbf{below normal}& 23 & 12 & 9 & 7 & 5 &3 \\\hline
         \textbf{lowest}& 22 & 11 & 8 & 6 & 4 & 2\\\hline
         \textbf{idle}& 16 & 1 & 1 & 1 & 1 & 1\\\hline
    \end{tabular}
    \label{tab:win_kernel_api}
\end{table}

В Windows также включен диспетчер настройки баланса, который сканирует очередь
готовых процессов 1 раз в секунду. Если он обнаруживает потоки, ожидающие выполнения
более 4 секунд, диспетчер настройки баланса повышает их приоритет до 15. Когда истекает
квант, приоритет потока снижается до базового приоритета. Если поток не был завершен за
квант времени или был вытеснен потоком с более высоким приоритетом, то после снижения
приоритета поток возвращается в очередь готовых потоков.

Текущий приоритет потока в динамическом диапазоне (от 1 до 15) может быть изменён
планировщиком вследствие следующих причин:
\begin{itemize}
    \item повышение приоритета после завершения операций ввода-вывода;
    \item повышение приоритета владельца блокировки;
    \item повышение приоритета вследствие ввода из пользовательского интерфейса;
    \item повышение приоритета вследствие длительного ожидания ресурса исполняющей
системы;
    \item повышение приоритета вследствие ожидания объекта ядра (семафора, события);
    \item повышение приоритета в случае, когда готовый к выполнению поток не был запущен
в течение длительного времени;
    \item повышение приоритета проигрывания мультимедиа службой планировщика \textbf{MMCSS}.
\end{itemize}

Текущий приоритет потока в динамическом диапазоне может быть понижен до базового
путем вычитания всех его повышений. В таблице~\ref{tab:pri_incr} приведены рекомендуемые значения
повышения приоритета для устройств ввода-вывода.


\begin{table}[H]
    \caption{Рекомендуемые значение повышения приоритета}
    \centering
    \begin{tabular}{|l|l|}
    \hline
         Устройство&Повышение приоритета\\\hline
\shortstack[l]{Жесткий диск, привод компакт-дисков,\\параллельный
порт, видеоустройство}&1\\\hline
\shortstack[l]{Сеть,
почтовый
слот,
именованный
канал,\\
последовательный порт}&2\\\hline
\shortstack[l]{
Клавиатура, мышь}&6\\\hline
\shortstack[l]{
Звуковая плата}&8\\\hline
    \end{tabular}
    \label{tab:pri_incr}
\end{table}

Потоки, на которых выполняются различные мультимедийные приложения, должны
выполняться с минимальными задержками. В Windows эта задача решается путем повышения
приоритетов таких потоков драйвером \textbf{MMCSS} --- MultiMedia Class Scheduler Service.
Приложения, которые реализуют воспроизведение мультимедиа, указывают драйверу \textbf{MMCSS}
задачу из списка:
\begin{itemize}
    \item аудио;
    \item игры;
    \item распределение;
    \item захват;
    \item воспроизведение;
    \item задачи администратора многоэкранного режима.
\end{itemize}

Функции драйвера MMCSS временно повышают приоритет потоков, зарегистрированных MMCSS до уровня, который соответствует категории планирования. Потом их приоритет снижается до уровня, соответствующего категории планирования Exhausted, для того, чтобы другие потоки могли также получить ресурс.

\subsection{Уровень запроса прерывания (IRQL)}

Windows устанавливает свою собственную схему приоритетности прерываний,
известную как IRQL. В ядре IRQL уровни представлены в виде номеров от 0 до 31 на
системах x86 и в виде номеров от 0 до 15 на системах x64 и IA64, где более высоким номерам
соответствуют прерывания с более высоким приоритетом. На рисунках~\ref{fig:IRQL_levels},~\ref{fig:IRQL_LEVELS2} показаны IRQL
для архитектур x86, x64 и IA64 соответственно.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{image.png}
    \caption{Уровни запросов прерываний для архитектуры x86}
    \label{fig:IRQL_levels}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{images/2.png}
    \caption{Уровни запросов прерываний IRQL для архитектур x64 и IA64}
    \label{fig:IRQL_LEVELS2}
\end{figure}
\chapter{Выводы}

Обработчики прерывания от системного таймера в защищенном режиме в системах Unix и Windows следующие действия:
\begin{itemize}
    \item выполняют декремент счетчиков времени: таймеров, счетчиков времени отложенных действий, будильников реального времени;
\item выполняют декремент кванта текущего процесса в Linux и декремент текущего
потока в Windows;
\item инициализируют отложенные действия, относящиеся к работе планировщика, такие
как пересчёт приоритетов.
\end{itemize}

Обе системы являются системами разделения времени с динамическими приоритетами
и вытеснением процессов. Динамические приоритеты пользовательских процессов позволяют исключить проблему бесконечного откладывания. Вытеснение процессов дает возможность поддерживать процессы реального времени, такие как аудио и видео.