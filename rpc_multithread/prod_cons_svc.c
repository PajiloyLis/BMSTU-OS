/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "prod_cons.h"
#include <stdio.h>
#include <stdlib.h>
#include <rpc/pmap_clnt.h>
#include <string.h>
#include <memory.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include "time.h"

#ifndef SIG_PF
#define SIG_PF void(*)(int)
#endif

pthread_t p_thread;
pthread_attr_t attr;

typedef struct thr_context {
    struct svc_req *rqstp;
    SVCXPRT *transp;
} thr_context;


void *
serve_request(void *data) {
    thr_context *params = (thr_context *) data;
    struct svc_req *rqstp = params->rqstp;
    register SVCXPRT *transp = params->transp;
    union {
        int service_1_arg;
    } argument;
    union {
        char service_1_res;
    } result;
    bool_t retval;
    xdrproc_t _xdr_argument, _xdr_result;
    bool_t(*local)(
    char *, void *, struct svc_req *);

    switch (rqstp->rq_proc) {
        case NULLPROC:
            (void) svc_sendreply(transp, (xdrproc_t) xdr_void, (char *) NULL);
            return;

        case service:
            _xdr_argument = (xdrproc_t) xdr_int;
            _xdr_result = (xdrproc_t) xdr_char;
            local = (bool_t (*)(char *, void *, struct svc_req *)) service_1_svc;
            break;

        default:
            svcerr_noproc(transp);
            return;
    }
    memset((char *) &argument, 0, sizeof(argument));
    if (!svc_getargs(transp, (xdrproc_t) _xdr_argument, (caddr_t) & argument)) {
        svcerr_decode(transp);
        return;
    }
    retval = (bool_t)(*local)((char *) &argument, (void *) &result, rqstp);
    if (retval > 0 && !svc_sendreply(transp, (xdrproc_t) _xdr_result, (char *) &result)) {
        svcerr_systemerr(transp);
    }
    if (!svc_freeargs(transp, (xdrproc_t) _xdr_argument, (caddr_t) & argument)) {
        fprintf(stderr, "%s", "unable to free arguments");
        pthread_exit(1);
    }
    if (!producer_consumer_prog_1_freeresult(transp, _xdr_result, (caddr_t) & result))
        fprintf(stderr, "%s", "unable to free results");

    return;
}

static void
producer_consumer_prog_1(struct svc_req *rqstp, register SVCXPRT *transp) {
    thr_context *params = (thr_context *) malloc(sizeof(thr_context));
    params->rqstp = rqstp;
    params->transp = transp;
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    pthread_create(&p_thread, &attr, serve_request, (void *) params);
}

int
main(int argc, char **argv) {
    register SVCXPRT *transp;

    pmap_unset(producer_consumer_prog, producer_consumer_ver);

    transp = svcudp_create(RPC_ANYSOCK);
    if (transp == NULL) {
        fprintf(stderr, "%s", "cannot create udp service.");
        exit(1);
    }
    if (!svc_register(transp, producer_consumer_prog, producer_consumer_ver, producer_consumer_prog_1, IPPROTO_UDP)) {
        fprintf(stderr, "%s", "unable to register (producer_consumer_prog, producer_consumer_ver, udp).");
        exit(1);
    }

    transp = svctcp_create(RPC_ANYSOCK, 0, 0);
    if (transp == NULL) {
        fprintf(stderr, "%s", "cannot create tcp service.");
        exit(1);
    }
    if (!svc_register(transp, producer_consumer_prog, producer_consumer_ver, producer_consumer_prog_1, IPPROTO_TCP)) {
        fprintf(stderr, "%s", "unable to register (producer_consumer_prog, producer_consumer_ver, tcp).");
        exit(1);
    }

    construct_semaphore_set(argv[0]);

    svc_run();
    fprintf(stderr, "%s", "svc_run returned");

    destruct_semaphore_set();
    exit(1);
    /* NOTREACHED */
}
